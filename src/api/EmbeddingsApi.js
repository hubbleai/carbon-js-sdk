/**
 * Carbon
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import ChunksAndEmbeddingsUploadInput from '../model/ChunksAndEmbeddingsUploadInput';
import DocumentResponseList from '../model/DocumentResponseList';
import EmbeddingsAndChunksQueryInput from '../model/EmbeddingsAndChunksQueryInput';
import EmbeddingsAndChunksResponse from '../model/EmbeddingsAndChunksResponse';
import GenericSuccessResponse from '../model/GenericSuccessResponse';
import GetEmbeddingDocumentsBody from '../model/GetEmbeddingDocumentsBody';
import HTTPValidationError from '../model/HTTPValidationError';

/**
* Embeddings service.
* @module api/EmbeddingsApi
* @version 1.0.0
*/
export default class EmbeddingsApi {

    /**
    * Constructs a new EmbeddingsApi. 
    * @alias module:api/EmbeddingsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the embeddingsEmbeddingsPost operation.
     * @callback module:api/EmbeddingsApi~embeddingsEmbeddingsPostCallback
     * @param {String} error Error message, if any.
     * @param {module:model/DocumentResponseList} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Embeddings
     * For pre-filtering documents, using `tags_v2` is preferred to using `tags` (which is now deprecated). If both `tags_v2` and `tags` are specified, `tags` is ignored. `tags_v2` enables building complex filters through the use of \"AND\", \"OR\", and negation logic. Take the below input as an example: ```json {     \"OR\": [         {             \"key\": \"subject\",             \"value\": \"holy-bible\",             \"negate\": false         },         {             \"key\": \"person-of-interest\",             \"value\": \"jesus christ\",             \"negate\": false         },         {             \"key\": \"genre\",             \"value\": \"religion\",             \"negate\": true         }         {             \"AND\": [                 {                     \"key\": \"subject\",                     \"value\": \"tao-te-ching\",                     \"negate\": false                 },                 {                     \"key\": \"author\",                     \"value\": \"lao-tzu\",                     \"negate\": false                 }             ]         }     ] } ``` In this case, files will be filtered such that: 1. \"subject\" = \"holy-bible\" OR 2. \"person-of-interest\" = \"jesus christ\" OR 3. \"genre\" != \"religion\" OR 4. \"subject\" = \"tao-te-ching\" AND \"author\" = \"lao-tzu\"  Note that the top level of the query must be either an \"OR\" or \"AND\" array. Currently, nesting is limited to 3. For tag blocks (those with \"key\", \"value\", and \"negate\" keys), the following typing rules apply: 1. \"key\" isn't optional and must be a `string` 2. \"value\" isn't optional and can be `any` or list[`any`] 3. \"negate\" is optional and must be `true` or `false`. If present and `true`, then the filter block is negated in the resulting query. It is `false` by default.   When querying embeddings, you can optionally specify the `media_type` parameter in your request. By default (if not set), it is equal to \"TEXT\". This means that the query will be performed over files that have been parsed as text (for now, this covers all files except image files). If it is equal to \"IMAGE\", the query will be performed over image files (for now, `.jpg` and `.png` files). You can think of this field as an additional filter on top of any filters set in `file_ids` and   When `hybrid_search` is set to true, a combination of keyword search and semantic search are used to rank and select candidate embeddings during information retrieval. By default, these search methods are weighted equally during the ranking process. To adjust the weight (or \"importance\") of each search method, you can use the `hybrid_search_tuning_parameters` property. The description for the different tuning parameters are: - `weight_a`: weight to assign to semantic search - `weight_b`: weight to assign to keyword search  You must ensure that `sum(weight_a, weight_b,..., weight_n)` for all *n* weights is equal to 1. The equality has an error tolerance of 0.001 to account for possible floating point issues.  In order to use hybrid search for a customer across a set of documents, two flags need to be enabled: 1. Use the `/modify_user_configuration` endpoint to to enable `sparse_vectors` for the customer. The payload body for this request is below: ``` {   \"configuration_key_name\": \"sparse_vectors\",   \"value\": {     \"enabled\": true   } } ``` 2. Make sure hybrid search is enabled for the documents across which you want to perform the search. For the `/uploadfile` endpoint, this can be done by setting the following query parameter: `generate_sparse_vectors=true`   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI's multimodal model; for text, we support OpenAI's `text-embedding-ada-002` and Cohere's embed-multilingual-v3.0. The model can be specified via the `embedding_model` parameter (in the POST body for `/embeddings`, and a query  parameter in `/uploadfile`). If no model is supplied, the `text-embedding-ada-002` is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with `OPENAI`, and files C and D have embeddings generated with `COHERE_MULTILINGUAL_V3`, then by default, queries will only consider files A and B. If `COHERE_MULTILINGUAL_V3` is specified as the `embedding_model` in `/embeddings`, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set `VERTEX_MULTIMODAL` as an `embedding_model`. This model is used automatically by Carbon when it detects an image file.
     * @param {String} authorization 
     * @param {module:model/GetEmbeddingDocumentsBody} getEmbeddingDocumentsBody 
     * @param {Object} opts Optional parameters
     * @param {String} [customerId] 
     * @param {module:api/EmbeddingsApi~embeddingsEmbeddingsPostCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/DocumentResponseList}
     */
    embeddingsEmbeddingsPost(authorization, getEmbeddingDocumentsBody, opts, callback) {
      opts = opts || {};
      let postBody = getEmbeddingDocumentsBody;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling embeddingsEmbeddingsPost");
      }
      // verify the required parameter 'getEmbeddingDocumentsBody' is set
      if (getEmbeddingDocumentsBody === undefined || getEmbeddingDocumentsBody === null) {
        throw new Error("Missing the required parameter 'getEmbeddingDocumentsBody' when calling embeddingsEmbeddingsPost");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
        'authorization': authorization,
        'customer-id': opts['customerId']
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = DocumentResponseList;
      return this.apiClient.callApi(
        '/embeddings', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the retrieveEmbeddingsAndContentTextChunksPost operation.
     * @callback module:api/EmbeddingsApi~retrieveEmbeddingsAndContentTextChunksPostCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EmbeddingsAndChunksResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Retrieve Embeddings And Content
     * @param {String} authorization 
     * @param {module:model/EmbeddingsAndChunksQueryInput} embeddingsAndChunksQueryInput 
     * @param {Object} opts Optional parameters
     * @param {String} [customerId] 
     * @param {module:api/EmbeddingsApi~retrieveEmbeddingsAndContentTextChunksPostCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EmbeddingsAndChunksResponse}
     */
    retrieveEmbeddingsAndContentTextChunksPost(authorization, embeddingsAndChunksQueryInput, opts, callback) {
      opts = opts || {};
      let postBody = embeddingsAndChunksQueryInput;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling retrieveEmbeddingsAndContentTextChunksPost");
      }
      // verify the required parameter 'embeddingsAndChunksQueryInput' is set
      if (embeddingsAndChunksQueryInput === undefined || embeddingsAndChunksQueryInput === null) {
        throw new Error("Missing the required parameter 'embeddingsAndChunksQueryInput' when calling retrieveEmbeddingsAndContentTextChunksPost");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
        'authorization': authorization,
        'customer-id': opts['customerId']
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = EmbeddingsAndChunksResponse;
      return this.apiClient.callApi(
        '/text_chunks', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the uploadChunksAndEmbeddingsUploadChunksAndEmbeddingsPost operation.
     * @callback module:api/EmbeddingsApi~uploadChunksAndEmbeddingsUploadChunksAndEmbeddingsPostCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GenericSuccessResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Upload Chunks And Embeddings
     * @param {String} authorization 
     * @param {module:model/ChunksAndEmbeddingsUploadInput} chunksAndEmbeddingsUploadInput 
     * @param {Object} opts Optional parameters
     * @param {String} [customerId] 
     * @param {module:api/EmbeddingsApi~uploadChunksAndEmbeddingsUploadChunksAndEmbeddingsPostCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GenericSuccessResponse}
     */
    uploadChunksAndEmbeddingsUploadChunksAndEmbeddingsPost(authorization, chunksAndEmbeddingsUploadInput, opts, callback) {
      opts = opts || {};
      let postBody = chunksAndEmbeddingsUploadInput;
      // verify the required parameter 'authorization' is set
      if (authorization === undefined || authorization === null) {
        throw new Error("Missing the required parameter 'authorization' when calling uploadChunksAndEmbeddingsUploadChunksAndEmbeddingsPost");
      }
      // verify the required parameter 'chunksAndEmbeddingsUploadInput' is set
      if (chunksAndEmbeddingsUploadInput === undefined || chunksAndEmbeddingsUploadInput === null) {
        throw new Error("Missing the required parameter 'chunksAndEmbeddingsUploadInput' when calling uploadChunksAndEmbeddingsUploadChunksAndEmbeddingsPost");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
        'authorization': authorization,
        'customer-id': opts['customerId']
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GenericSuccessResponse;
      return this.apiClient.callApi(
        '/upload_chunks_and_embeddings', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
